from bot.logic import BotLogic
#from scheduler import schedule_tasks

video_data = [
    {"topic": "Arrays", "problem": "Problem: Explain Arrays and solve a problem using arrays.", "solution": "Solution: Arrays are a collection of items stored at contiguous memory locations. They are used to store data of the same type and provide fast access to elements via indexing."},
    {"topic": "Linked Lists", "problem": "Problem: Explain Linked Lists and solve a problem using linked lists.", "solution": "Solution: Linked lists are a linear data structure where elements, called nodes, are stored in a sequence. Each node contains a data part and a reference to the next node. Linked lists are useful for dynamic data structures where size changes frequently."},
    {"topic": "Stacks", "problem": "Problem: Explain Stacks and solve a problem using stacks.", "solution": "Solution: A stack is a linear data structure that follows the Last In, First Out (LIFO) principle. It is used in scenarios such as undo mechanisms in text editors, function calls, and evaluating expressions."},
    {"topic": "Queues", "problem": "Problem: Explain Queues and solve a problem using queues.", "solution": "Solution: A queue is a linear data structure that follows the First In, First Out (FIFO) principle. It is often used in situations like scheduling tasks, printer management, or handling requests in a web server."},
    {"topic": "Hash Maps", "problem": "Problem: Explain Hash Maps and solve a problem using hash maps.", "solution": "Solution: A hash map is a data structure that stores key-value pairs. It allows for fast access, insertion, and deletion of data using a hash function. Hash maps are widely used in scenarios like caching, databases, and implementing associative arrays."},
    {"topic": "Binary Search Trees", "problem": "Problem: Explain Binary Search Trees and solve a problem using binary search trees.", "solution": "Solution: A binary search tree is a tree data structure in which each node has at most two children. The left child’s value is less than the parent’s value, and the right child’s value is greater. It’s used to perform efficient searching, insertion, and deletion."},
    {"topic": "Heaps", "problem": "Problem: Explain Heaps and solve a problem using heaps.", "solution": "Solution: A heap is a special tree-based data structure that satisfies the heap property. A max heap allows the largest element to be at the root, and a min heap allows the smallest. Heaps are often used in implementing priority queues and for heap sort."},
    {"topic": "Graphs", "problem": "Problem: Explain Graphs and solve a problem using graphs.", "solution": "Solution: A graph is a collection of nodes (vertices) and edges (connections between nodes). Graphs are used to model relationships between entities and are fundamental in algorithms for network routing, shortest path finding, and social network analysis."},
    {"topic": "Trie", "problem": "Problem: Explain Trie and solve a problem using trie.", "solution": "Solution: A trie, or prefix tree, is a tree-like data structure used for storing a dynamic set of strings. It is especially useful for tasks like autocomplete, spell checking, and IP routing."},
    {"topic": "Graphs and Shortest Path Algorithms", "problem": "Problem: Explain Graphs and Shortest Path Algorithms and solve a problem using these concepts.", "solution": "Solution: Graphs represent networks of nodes, and shortest path algorithms, such as Dijkstra’s and Bellman-Ford, are used to find the shortest path between nodes. These algorithms are crucial in network routing and mapping applications."},
    {"topic": "Breadth-First Search", "problem": "Problem: Explain Breadth-First Search and solve a problem using BFS.", "solution": "Solution: BFS is a graph traversal algorithm that explores all nodes at the present depth level before moving on to nodes at the next depth level. It’s used in finding the shortest path in unweighted graphs."},
    {"topic": "Depth-First Search", "problem": "Problem: Explain Depth-First Search and solve a problem using DFS.", "solution": "Solution: DFS is a graph traversal algorithm where you explore as far down a branch of the graph as possible before backtracking. It’s used in pathfinding and for topological sorting."},
    {"topic": "Binary Search", "problem": "Problem: Explain Binary Search and solve a problem using binary search.", "solution": "Solution: Binary search is an efficient algorithm for finding an element in a sorted list by repeatedly dividing the search interval in half. It’s used for search operations in large datasets."},
    {"topic": "Sorting Algorithms", "problem": "Problem: Explain Sorting Algorithms and solve a problem using sorting.", "solution": "Solution: Sorting algorithms like QuickSort, MergeSort, and BubbleSort are used to arrange data in a particular order. Sorting is a fundamental operation in computer science used to optimize the performance of other algorithms."},
    {"topic": "Merge Sort", "problem": "Problem: Explain Merge Sort and solve a problem using merge sort.", "solution": "Solution: Merge Sort is a divide-and-conquer algorithm that splits the list into halves, sorts each half, and then merges them. It has a time complexity of O(n log n) and is often used in large datasets."},
    {"topic": "Quick Sort", "problem": "Problem: Explain Quick Sort and solve a problem using quick sort.", "solution": "Solution: QuickSort is an efficient, divide-and-conquer sorting algorithm. It works by selecting a pivot and partitioning the array into two subarrays, sorting them independently. Its average time complexity is O(n log n)."},
    {"topic": "Bubble Sort", "problem": "Problem: Explain Bubble Sort and solve a problem using bubble sort.", "solution": "Solution: Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. While easy to implement, it has a time complexity of O(n²)."},
    {"topic": "Insertion Sort", "problem": "Problem: Explain Insertion Sort and solve a problem using insertion sort.", "solution": "Solution: Insertion Sort builds the sorted list one element at a time by comparing each element to the ones before it and inserting it into the correct position. It’s efficient for small datasets."},
    {"topic": "Selection Sort", "problem": "Problem: Explain Selection Sort and solve a problem using selection sort.", "solution": "Solution: Selection Sort is an in-place, comparison-based algorithm that divides the list into two parts: the sorted part and the unsorted part. It selects the minimum element from the unsorted part and moves it to the sorted part."},
    {"topic": "Radix Sort", "problem": "Problem: Explain Radix Sort and solve a problem using radix sort.", "solution": "Solution: Radix Sort is a non-comparative sorting algorithm that sorts numbers digit by digit, starting from the least significant digit. It’s efficient for sorting large datasets with a fixed range of values."},
    {"topic": "Counting Sort", "problem": "Problem: Explain Counting Sort and solve a problem using counting sort.", "solution": "Solution: Counting Sort is an integer sorting algorithm that counts the number of occurrences of each element in the input. It’s very efficient when the range of input values is small."},
    {"topic": "Bucket Sort", "problem": "Problem: Explain Bucket Sort and solve a problem using bucket sort.", "solution": "Solution: Bucket Sort is a comparison-based sorting algorithm that divides the input into buckets, sorts each bucket, and then merges the results. It works well when the input is uniformly distributed."},
    {"topic": "Shell Sort", "problem": "Problem: Explain Shell Sort and solve a problem using shell sort.", "solution": "Solution: Shell Sort is an in-place sorting algorithm that generalizes insertion sort to allow the exchange of items that are far apart. It’s faster than simple insertion sort for large lists."},
    {"topic": "Topological Sorting", "problem": "Problem: Explain Topological Sorting and solve a problem using topological sort.", "solution": "Solution: Topological sorting is the linear ordering of vertices in a Directed Acyclic Graph (DAG). It’s used in scheduling tasks where some tasks must be completed before others."}
]

d = BotLogic()
d.setup("config/cookies.json")
for i in video_data:
    try:
        audio, duration = d.get_audio(i["topic"], i["problem"]+" "+i["solution"])
        images = d.get_image_with_keyword(i["topic"],round(duration/5))
        image_durations = [duration/ len(images) for i in images]
        video = d.make_video(i["topic"],i["problem"], audio, images, image_durations)
        d.upload_video(i["problem"], video)
    except:
        pass

